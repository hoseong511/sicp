#lang sicp
(define (make-mobile left right)
  (cons left right))
(define (make-branch len strc)
  (cons len strc))
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-len branch)
  (car branch))
(define (branch-strc branch)
  (cdr branch))

;b
(define (total-weight mobile)
  (define (check branch)
    (if (not (pair? (branch-strc branch)))
        (branch-strc branch)
        (total-weight (branch-strc branch))))
  (let ((left (left-branch mobile))
        (right (right-branch mobile)))
    (+ (check left) (check right))))

;c
(define (balanced? mobile)
  (define check (lambda (x) (if (not (pair? (branch-strc x))) 1 0)))
  (let ((letf (left-branch mobile))
        (right (right-branch mobile)))
    (cond ((and (= (check left) 1) (= (check right) 1)) (= (* (branch-strc left) (branch-len left))
                                                           (* (branch-strc right) (branch-len left))))
          ((and (= (check left) 0) (= (check right) 1)) (= (* (total-weight (branch-strc left)) (branch-len left))
                                                           (* (branch-strc right) (branch-len right))))
          ((and (= (check left) 1) (= (check right) 0)) (= (* (branch-strc left) (branch-len left))
                                                           (* (total-weight (branch-strc right)) (branch-len right))))
          ((and (= (check left) 0) (= (check right) 0)) (= (* (total-weight (branch-strc left)) (branch-len left))
                                                           (* (total-weight (branch-strc right)) (branch-len right)))))))

(define left (make-branch 0 3))
(define right (make-branch 0 2))
(define mobile (make-mobile left right))
(define left2 (make-branch 0 3))
(define right2 (make-branch 0 mobile))

(branch-strc right2)
(right-branch mobile)
(define mobile2 (make-mobile left2 right2))
(total-weight mobile2)
(balanced? mobile2)